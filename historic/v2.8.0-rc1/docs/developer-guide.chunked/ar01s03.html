<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. Information for developers</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="index.html" title="Network UPS Tools Developer Guide" /><link rel="up" href="index.html" title="Network UPS Tools Developer Guide" /><link rel="prev" href="ar01s02.html" title="2. NUT design document" /><link rel="next" href="ar01s04.html" title="4. Creating a new driver to support another device" /><meta xmlns="" name="format-detection" content="telephone=no" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="developers"></a>3. Information for developers</h2></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Two NUT websites</h3><p>This version of the page reflects NUT release <span class="emphasis"><em>v2.8.0-rc1</em></span>
with codebase commited 86af0b98c at 2022-04-01T02:02:27+02:00</p><p>Options, features and capabilities in current development (and future
releases) are detailed on the main site and may differ from ones
described here.</p></div><p>This document is intended to explain some of the more useful things
within the tree, and provide a standard for working on the code.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_general_stuff_8201_8212_8201_common_subdirectory"></a>3.1. General stuff — common subdirectory</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_string_handling"></a>String handling</h4></div></div></div><p>Use <code class="literal">snprintf()</code>.  It’s even provided with a compatibility module if the
target system doesn’t have it natively.</p><p>If you use <code class="literal">snprintf()</code> to load some value into a buffer, make sure you
provide the format string.  Don’t use user-provided format strings,
since that’s an easy way to open yourself up to an exploit.</p><p>Don’t use <code class="literal">strcat()</code>.  We have a neat wrapper for <code class="literal">snprintf()</code> called
<code class="literal">snprintfcat()</code> that allows you to append to <code class="literal">char *</code> with a format
string and all the usual string length checking of <code class="literal">snprintf()</code> routine.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_error_reporting"></a>Error reporting</h4></div></div></div><p>Don’t call <code class="literal">syslog()</code> directly.  Use <code class="literal">upslog_with_errno()</code> and <code class="literal">upslogx()</code>.
They may write to the syslog, stderr, or both as appropriate.  This
means you don’t have to worry about whether you’re running in the
background or not.</p><p>The <code class="literal">upslog_with_errno()</code> routine prints your message plus the string
expansion of <code class="literal">errno</code>. The <code class="literal">upslogx()</code> just prints the message.</p><p><code class="literal">fatal_with_errno()</code> and <code class="literal">fatalx()</code> work the same way, but they
also <code class="literal">exit(EXIT_FAILURE)</code> afterwards. Don’t call <code class="literal">exit()</code> directly.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_debugging_information"></a>Debugging information</h4></div></div></div><p>The <code class="literal">upsdebug_with_errno()</code>, <code class="literal">upsdebugx()</code>, <code class="literal">upsdebug_hex()</code> and
<code class="literal">upsdebug_ascii()</code> routines use the global <code class="literal">nut_debug_level</code>, so you
don’t have to mess around with `printf()`s and `if`s yourself.
Use them.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_memory_allocation"></a>Memory allocation</h4></div></div></div><p><code class="literal">xmalloc()</code>, <code class="literal">xcalloc()</code>, <code class="literal">xrealloc()</code> and <code class="literal">xstrdup()</code> all check the
results of the base calls before continuing, so you don’t have to.
Don’t use the raw calls directly.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_config_file_parsing"></a>Config file parsing</h4></div></div></div><p>The configuration parser, called parseconf, is now up to its fourth
major version.  It has multiple entry points, and can handle many
different jobs.  It’s usually used for parsing files, but it can also
take input a line at a time or even a character at a time.</p><p>You must initialize a context buffer with pconf_init before using any
other parseconf function.  pconf_encode is the only exception, since it
operates on a buffer you supply and is an auxiliary function.</p><p>Escaping special characters and quoting multiple-word elements is all
handled by the state machine.  Using the same code for all config files
avoids code duplication.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>this does not apply to drivers.  Driver authors should use the
<code class="literal">upsdrv_makevartable()</code> scheme to pick up values from ups.conf.
Drivers should not have their own config files.</p></div><p>Drivers may have their own data files, such as lists of hardware,
mapping tables, or similar.  The difference between a data file and a
config file is that users should never be expected to edit a data file
under normal circumstances.  This technique might be used to add more
hardware support to a driver without recompiling.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_lt_time_h_gt_vs_lt_sys_time_h_gt"></a>&lt;time.h&gt; vs. &lt;sys/time.h&gt;</h4></div></div></div><p>This is already handled by autoconf, so just include "timehead.h" and you
will get the right headers on every system.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_device_drivers_8201_8212_8201_main_c"></a>3.2. Device drivers — main.c</h3></div></div></div><p>The device drivers use main.c as their core.</p><p>To write a new driver, you create a file with a series of support
functions that will be called by main.  These all have names that start
with <code class="literal">upsdrv_</code>, and they will be called at different times by main
depending on what needs to happen.</p><p>See the <a class="link" href="ar01s04.html" title="4. Creating a new driver to support another device">driver documentation</a> for information on writing
drivers, and also refer to the skeletal driver in skel.c.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_portability"></a>3.3. Portability</h3></div></div></div><p>Avoid things that will break on other systems.  All the world is not an
x86 Linux box.</p><p>There are still older systems out there that don’t do C++ style comments.</p><pre class="screen">/* Comments look like this. */
// Not like this.</pre><p>Newer versions of gcc allow you to declare a variable inside a function
after code, somewhat like the way C++ operates, like this:</p><pre class="screen">function do_stuff(void)
{
        check_something();

        int a;

        a = do_something_else();
}</pre><p>While this will compile and run on these newer versions, it will fail
miserably for anyone on an older system.  That means you must not use
it.  gcc only warns about this with -pedantic.</p><p>Another feature that does not work on some compilers (e.g. conforming
to "ANSI C"/C89/C90 standard) is initial variable declaration inside a
<span class="emphasis"><em>for loop</em></span> block, like this:</p><pre class="screen">function do_stuff(void)
{
        /* This should declare "int i;" first, then use it in "for" loop: */
        for (int i = 0; i &lt; INT_MAX; ++i) { ... }

        /* Additional loops cause also an error about re-declaring a variable: */
        for (int i = 10; i &lt; 15; ++i) { ... }
}</pre><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>At this point NUT is expected to work correctly when built with a
C99 (or rather GNU99 on many systems) or newer standard.</p></div><p>The NUT codebase may build in a mode without warnings made fatal on C89
(GNU89), but the emitted warnings indicate that those binaries may crash.
By the end of 2021, NUT codebase has been revised to pass GNU and strict-C
mode builds with C89 standard with the GCC toolkit (and on systems that do
have the newer features in libraries, just hide them in standard headers);
however CLANG toolkit is more restrictive about the C99+ syntax used.
If somebody in the community requires to build and run NUT on systems
that old, pull requests to fix the offending coding issues are welcome.</p><p>Note also that the NUT codebase currently relies on certain features,
such as the printf format modifiers for <code class="literal">(s)size_t</code>, use of <code class="literal">long long</code>,
some nuances about structure/array initializers, variadic macros for
debugging, etc. that a pedantic C90 mode compilation warns is not part
of the standard but a GNU extension (and part of C99 and newer standard
revisions). Many of the "offences" against the older standard actually
come from system and third-party header files.</p><p>That said, the NUT CI farm does run non-regression builds with GNU C89
and strict C89 standard revisions and minimal passing warnings level,
to ensure that codebase is and remains at least basically compliant.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_continuous_integration_and_automated_builds"></a>3.4. Continuous Integration and Automated Builds</h3></div></div></div><p>To ease and automate the build scenarios which were deemed important for
quality assurance and non-regression checks of NUT, several solutions
were introduced over time.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_ci_build_sh"></a>ci_build.sh</h4></div></div></div><p>This script was originally introduced (following ZeroMQ/ZProject example)
to automate CI builds, by automating certain scenarios driven by exported
environment variables to set particular <code class="literal">configure</code> options and <code class="literal">make</code>
some targets (chosen by the <code class="literal">BUILD_TYPE</code> envvar). It can also be used
locally to avoid much typing to re-run those scenarios during development.</p><p>Developers can directly use the scripts involved in CI builds to fix
existing code on their workstations or to ensure support for new
compilers and C standard revisions, e.g. save a local file like this
to call the common script with pre-sets:</p><pre class="literallayout">$ cat _fightwarn-gcc10-gnu17.sh
#!/bin/sh</pre><pre class="literallayout">BUILD_TYPE=default-all-errors \
CFLAGS="-Wall -Wextra -Werror -pedantic -std=gnu17" \
CXXFLAGS="-Wall -Wextra -Werror -std=gnu++17" \
CC=gcc-10 CXX=g++-10 \
        ./ci_build.sh</pre><p>…and then execute it to prepare a workspace, after which you can go
fixing bugs file-by-file running a <code class="literal">make</code> after each save to confirm
your solutions and uncover the next issue to address :-)</p><p>Helpfully, the NUT CI farm build logs report the configuration used for
each executed stage, so if some build combination fails — you can just
scroll to the end of that section and copy-paste the way to reproduce
an issue locally (on an OS similar to that build case).</p><p>Note that while spelling out sets of warnings can help in a quest to
fix certain bugs during development (if only by removing noise from
classes of warnings not relevant to the issue one is working on), there
is a reasonable set of warnings which NUT codebase actively tries to
be clean about (and checks in CI), detailed in the next section.</p><p>For the <code class="literal">ci_build.sh</code> usage like above, one can instead pass the setting
via <code class="literal">BUILD_WARNOPT=...</code>, and require that all emitted warnings are fatal
for their build, e.g.:</p><pre class="literallayout">$ cat _fightwarn-clang9-gnu11.sh
#!/bin/sh</pre><pre class="literallayout">BUILD_TYPE=default-all-errors \
BUILD_WARNOPT=hard BUILD_WARNFATAL=yes \
CFLAGS="-std=gnu11" \
CXXFLAGS="-std=gnu++11" \
CC=clang-9 CXX=clang++-9 CPP=clang-cpp \
        ./ci_build.sh</pre><p>Finally, for refactoring effort geared particularly for fighting the
warnings which exist in current codebase, the script contains some
presets (which would evolve along with codebase quality improvements)
as <code class="literal">BUILD_TYPE=fightwarn-gcc</code>, <code class="literal">BUILD_TYPE=fightwarn-clang</code> or plain
<code class="literal">BUILD_TYPE=fightwarn</code>:</p><pre class="literallayout">BUILD_TYPE=fightwarn-clang ./ci_build.sh</pre><p>As a rule of thumb, new contributions must not emit any warnings when
built in GNU99 mode with a <code class="literal">minimal</code> "difficulty" level of warnings.
Technically they must survive the part of test matrix across the several
platforms tested by NUT CI and marked in project settings as required
to pass, to be accepted for a pull request merge.</p><p>Developers aiming to post successful pull requests to improve NUT can
pass the <code class="literal">--enable-warnings</code> option to the <code class="literal">configure</code> script in local
builds to see how that behaves and ensure that at least in some set-up
their contribution is viable. Note that different compiler versions and
vendors (gcc/clang/…), building against different OS and third-party
dependencies, with different CPU architectures and different language
specification revisions, might all complain about different issues — and catching this in as diverse range of set-ups as possible is why we
have CI tests.</p><p>It can be beneficial for serial developers to set up a local BuildBot,
Travis or a Jenkins instance with a matrix test job, to test their local
git repository branches with whatever systems they have available.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="ulink" href="https://github.com/networkupstools/nut/issues/823" target="_top">https://github.com/networkupstools/nut/issues/823</a>
</li></ul></div><p>While <code class="literal">autoconf</code> tries its best to provide portable shell code, sometimes
there are builds of system shell that just fail under stress. If you are
seeing random failures of <code class="literal">./configure</code> script in different spots with
the same inputs, try telling <code class="literal">./ci_build.sh</code> to loop configuring until
success (instead of quickly failing), and/or tell <code class="literal">./configure</code> to use
another shell at least for the system call-outs, with options like these:</p><pre class="literallayout">SHELL=/bin/bash CONFIG_SHELL=/bin/bash CI_SHELL_IS_FLAKY=true \
./ci_build.sh</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_jenkins_ci"></a>Jenkins CI</h4></div></div></div><p>Since mid-2021, the NUT CI farm is implemented by several virtual servers
courteously provided by <a class="ulink" href="http://fosshost.org" target="_top">http://fosshost.org</a></p><p>These run various operating systems as build agents, and a Jenkins instance
to orchestrate the builds of NUT branches and pull requests on those agents.</p><p>This is driven by <code class="literal">Jenkinsfile-dynamatrix</code> and a Jenkins Shared Library called
<a class="ulink" href="https://github.com/networkupstools/jenkins-dynamatrix" target="_top">jenkins-dynamatrix</a>
which prepares a matrix of builds across as many operating systems,
bitnesses/architectures, compilers, make programs and C/C++ revisions
as it can — based on the population of currently available build agents
and capabilities which they expose as agent labels.</p><p>This hopefully means that people interested in NUT can contribute to the
build farm (and ensure NUT is and remains compatible with their platform)
by running a Jenkins Swarm agent with certain labels, which would dial
into <a class="ulink" href="https://ci.networkupstools.org/" target="_top">https://ci.networkupstools.org/</a> controller. Please contact the NUT
maintainer if you want to participate in this manner.</p><p>The <code class="literal">Jenkinsfile-dynamatrix</code> recipe allows NUT CI farm to run different sets
of build scenarios based on various conditions, such as the name of branch
being built (or PR’ed against), changed files (e.g. C/C++ sources vs. just
docs), and some build combinations may be not required to succeed.</p><p>For example, the main development branch and pull requests against it must
cleanly pass all specified builds and tests on various platforms with the
default level of warnings specified in the <code class="literal">configure</code> script. These are
balanced to not run too many build scenarios overall, but just a quick and
sufficiently representative set.</p><p>As another example, there is special handling for "fightwarn" pattern in
the branch names to run many more builds with varying warning levels and
more variants of intermediate language revisions, and so expose concerns
deliberately missed by default warnings levels in "master" branch builds
(the bar moves over time, as some classes of warnings become extinct from
our codebase).</p><p>Further special handling for branches named like <code class="literal">fightwarn.*89.*</code> regex
enables more intensive warning levels for a GNU89 build specifically (which
are otherwise disabled as noisy yet not useful for supported C99+ builds),
and is intended to help develop fixes for support of this older language
revision, if anyone would dare.</p><p>Many of those unsuccessful build stages are precisely the focus of the
"fightwarn" effort, and are currently marked as "may fail", so they end
up as "UNSTABLE" (seen as orange bubbles in the Jenkins BlueOcean UI, or
orange cells in the tabular list of stages in the legacy UI), rather than
as "FAILURE" (red bubbles) for build scenarios that were not expected to
fail and usually represent higher-priority problems that would block a PR.</p><p>Developers whose PR builds (or attempts to fix warnings) did not succeed in
some cell of such build matrix, can look at the individual logs of that cell.
Beside indication from the compiler about the failure, the end of log text
includes the command which was executed by CI worker and can be reproduced
locally by the developer, e.g.:</p><pre class="screen">22:26:01  FINISHED with exit-code 2 cmd:  (
22:26:01  [ -x ./ci_build.sh ] || exit
22:26:01
22:26:01  eval BUILD_TYPE="default-alldrv" BUILD_WARNOPT="hard" \
    BUILD_WARNFATAL="yes" MAKE="make"  CC=gcc-10 CXX=g++-10 \
    CPP=cpp-10 CFLAGS='-std=gnu99 -m64' CXXFLAGS='-std=gnu++11 -m64' \
    LDFLAGS='-m64' ./ci_build.sh
22:26:01  )</pre><p>or for autotools-driven scenarios (which prep, configure, build and test
in separate stages — so for reproducing a failed build you should also
look at its configuration step separately):</p><pre class="screen">22:28:18  FINISHED with exit-code 0 cmd:  ( [ -x configure ] || exit; \
    eval  CC=clang-9 CXX=clang++-9 CPP=clang-cpp-9 CFLAGS='-std=c11 -m64' \
    CXXFLAGS='-std=c++11 -m64' LDFLAGS='-m64' time ./configure )</pre><p>To re-run such scenario locally, you can copy the line from <code class="literal">eval</code> (but
without the <code class="literal">eval</code> keyword itself) up to and including the executed script
or tool, into your shell. Depending on locally available compilers, you
may have to tweak the <code class="literal">CC</code>, <code class="literal">CXX</code> and <code class="literal">CPP</code> arguments; note that a <code class="literal">CPP</code>
may be specified as <code class="literal">/path/to/CC -E</code> for GCC and CLANG based toolkits
at least, if they lack a standalone preprocessor program (e.g. IntelCC).</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>While NUT recipes do not currently recognize a separate <code class="literal">CXXCPP</code>,
it would follow similar semantics.</p></div><p>Some further details about the NUT CI farm workers are available in
<a class="ulink" href="config-prereqs.txt" target="_top">config-prereqs.txt</a> and
<a class="ulink" href="ci-farm-lxc-setup.txt" target="_top">ci-farm-lxc-setup.txt</a> documents.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_travis_ci"></a>Travis CI</h4></div></div></div><p>See the <code class="literal">.travis.yml</code> file in project sources for a detailed list of third
party dependencies and a large matrix of <code class="literal">CFLAGS</code> and compiler versions
last known to work or to not (yet) work on operating systems available
to that CI solution.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The cloud Travis CI offering became effectively defunct for
open-source projects in mid-2021, so the <code class="literal">.travis.yml</code> file in NUT
codebase is not actively maintained.</p></div><p>+
Local private deployments of Travis CI are possible, so if anybody does
use it and has updated markup to share, they are welcome to post PRs.</p><p>The NUT project on GitHub has integration with Travis CI to test a large
set of compiler and option combinations, covering different versions of
gcc and clang, C standards, and requiring to pass builds at least in a
mode without warnings (and checking the other cases where any warnings
are made fatal).</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_pre_set_warning_options"></a>Pre-set warning options</h4></div></div></div><p>The options chosen into pre-sets that can be selected by <code class="literal">configure</code>
script options are ones we use for different layers of CI tests.</p><p>Values to note include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">--enable-Werror(=yes/no)</code> — make warnings fatal;
</li><li class="listitem"><p class="simpara">
<code class="literal">--enable-warnings(=.../no)</code> — enable certain warning presets:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<code class="literal">gcc-hard</code>, <code class="literal">clang-hard</code>, <code class="literal">gcc-medium</code>, <code class="literal">clang-medium</code>, <code class="literal">gcc-minimal</code>,
   <code class="literal">clang-minimal</code>, <code class="literal">all</code> — actual definitions that are compiler-dependent
   (the latter just adds <code class="literal">-Wall</code> which may be relatively portable);
</li><li class="listitem">
<code class="literal">hard</code>, <code class="literal">medium</code> or <code class="literal">minimal</code> — if current compiler is detected as
   CLANG or GCC, apply corresponding setting from above (or <code class="literal">all</code> otherwise);
</li><li class="listitem">
<code class="literal">gcc</code> or <code class="literal">clang</code> — apply the set of options (regardless of detected
   compiler) with default "difficulty" hard-coded in <code class="literal">configure</code> script,
   to tweak as our codebase becomes cleaner;
</li><li class="listitem">
<code class="literal">yes</code>/<code class="literal">auto</code> (also takes effect if <code class="literal">--enable-warnings</code> is requested
   without an <code class="literal">=ARG</code> part) — if current compiler is detected as CLANG
   or GCC, apply corresponding setting with default "difficulty" from
   above (or <code class="literal">all</code> otherwise).
</li></ul></div></li></ul></div><p>Note that for backwards-compatibility reasons and to help filter out
introduction of blatant errors, builds with compilers that claim GCC
compatibility can enable a few easy warning presets by default. This
can be avoided with an explicit argument to <code class="literal">--disable-warnings</code> (or
<code class="literal">--enable-warnings=no</code>).</p><p>All levels of warnings pre-sets for GCC in particular do not enforce
the <code class="literal">-pedantic</code> mode for builds with C89/C90/ANSI standard revision
(as guesstimated by <code class="literal">CFLAGS</code> content), because nowadays it complains
more about the system and third-party library headers, than about NUT
codebase quality (and "our offenses" are mostly something not worth
fixing in this era, such as the use of <code class="literal">__func__</code> in debug commands).
If there still are practical use-cases that require builds of NUT on
pre-C99 compiler toolkits, pull requests are of course welcome — but
the maintainer team does not intend to spend much time on that.</p><p>Hopefully this warnings pre-set mechanism is extensible enough if we
would need to add more compilers and/or "difficulty levels" in the
future.</p><p>Finally, note that such pre-set warnings can be mixed with options
passed through <code class="literal">CFLAGS</code> or <code class="literal">CXXFLAGS</code> values to your local <code class="literal">configure</code>
run, but it is up to your compiler how it interprets the resulting mix.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_coding_style"></a>3.5. Coding style</h3></div></div></div><p>This is how we do things:</p><pre class="screen">int open_subspace(char *ship, int privacy)
{
        if (!privacy)
                return insecure_channel(ship);

        if (!init_privacy(ship))
                fatal_with_errno("Can't open secure channel");

        return secure_channel(ship);
}</pre><p>The basic idea is that we try to group things into functions, and then
find ways to drop out of them when we can’t go any further.  There’s
another way to program this involving a big else chunk and a bunch of
braces, and it can be hard to follow.  You can read this from top to
bottom and have a pretty good idea of what’s going on without having to
track too much { } nesting and indenting.</p><p>We don’t really care for pretentiousVariableNamingSchemes, but you can
probably get away with it in your own driver that we will never have to
touch.  If your function or variable names start pushing important code
off the right margin of the screen, expect them to meet the byte
chainsaw sooner or later.</p><p>All types defined with typedef should end in "_t", because this is
easier to read, and it enables tools (such as indent and emacs) to
display the source code correctly.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_indenting_with_tabs_vs_spaces"></a>Indenting with tabs vs. spaces</h4></div></div></div><p>Another thing to notice is that the indenting happens with tabs instead
of spaces.  This lets everyone have their personal tab-width setting
without inflicting much pain on other developers.  If you use a space,
then you’ve fixed the spacing in stone and have really annoyed half of
the people out there.</p><p>Note that tabs apply only to <span class="strong"><strong>indenting</strong></span>.  Alignment of text after any
non-tab character has appeared on the line must be done by spaces in
order for it to remain at the same alignment when someone views tabs at
a different widths.</p><p>One common example for this is multi-line if condition:</p><pre class="screen">        if (something &amp;&amp;
            something_else) {</pre><p>Another example is tables of definitions that are better aligned with
(non-leading) spaces at least between names and values not too many
characters wide; it still helps to align the columns with spaces at
offsets divisible by 4 or 8 (consistently for the whole table):</p><pre class="screen">#define SHORT_MACRO                         1   /* flag comment */
#define SOMETHING_WITH_A_VERY_LONG_NAME     255 /* flag comment */</pre><p>If you write something that uses leading spaces, you may get away with
it in a driver that’s relatively secluded.  However, if we have to work
on that code, expect it to get reformatted according to the above.</p><p>Patches to existing code that don’t conform to the coding style being
used in that file will probably be dropped.  If it’s something we really
need, it will be grudgingly reformatted before being included.</p><p>When in doubt, have a look at Linus’s take on this topic in the Linux
kernel — Documentation/CodingStyle.  He’s done a far better job of
explaining this.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_line_breaks"></a>Line breaks</h4></div></div></div><p>It is better to have lines that are longer than 80 characters than to
wrap lines in random places. This makes it easier to work with tools
such as "grep", and it also lets each developer choose their own
window size and tab setting without being stuck to one particular
choice.</p><p>Of course, this does not mean that lines should be made unnecessarily
long when there is a better alternative (see the note on
pretentiousVariableNamingSchemes above).  Certainly there should not
be more than one statement per line. Please do not use</p><pre class="screen">if (condition) break;</pre><p>but use the following:</p><pre class="screen">if (condition) {
        break;
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_un_used_variables_and_function_arguments"></a>Un-used variables and function arguments</h4></div></div></div><p>Whenever a function needs to satisfy a particular API, it can end up
taking arguments that are not used in practice (think a too-trivial
signal handler). While some compilers offer the facility of decorations
like <code class="literal">__attribute__(unused)</code>, this proved not to be a portable solution.
Also the abilities of newer C++ standard revisions are of no help to
the vast range of existing systems that run NUT today and expect to be
able to do so tomorrow (hence the required C99+ support noted above).</p><p>In NUT codebase we prefer to mark un-used variables explicitly in the
body of the function (or an <code class="literal">#ifdef</code> branch of its code) using the
<code class="literal">NUT_UNUSED_VARIABLE(varname)</code> as a routine call inside a function
body, referring to the macro defined in <code class="literal">common.h</code>.</p><p>To display in a rough example:</p><pre class="screen">        static void signal_X_handler(int signal_X) {
                NUT_UNUSED_VARIABLE(signal_X);
                /* We have explicitly got nothing to do if we catch signal X */
                return;
        }</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_miscellaneous_coding_style_tools"></a>3.6. Miscellaneous coding style tools</h3></div></div></div><p>You can go a long way towards converting your source code to the NUT
coding style by piping it through the following command:</p><pre class="literallayout">indent -kr -i8 -T FILE -l1000 -nhnl</pre><p>This next command does a reasonable job of converting most C++ style
comments (but not URLs and DOCTYPE strings):</p><pre class="literallayout">sed 's#\(^\|[ \t]\)//[ \t]*\(.*\)[ \t]*#/* \2 */#'</pre><p>Emacs users can adjust how tabs are displayed. For example, it is
possible to set a tab stop to be 3 spaces, rather than the usual 8.
(Note that in the saved file, one indentation level will still
correspond to one tab stop; the difference is only how the file is
rendered on screen). It is even possible to set this on a
per-directory basis, by putting something like this into your .emacs
file:</p><pre class="screen">;; NUT style

(defun nut-c-mode ()
 "C mode with adjusted defaults for use with the NUT sources."
 (interactive)
 (c-mode)
 (c-set-style "K&amp;R")
 (setq c-basic-offset 3)  ;; 3 spaces C-indentation
 (setq tab-width 3))      ;; 3 spaces per tab

;; apply NUT style to all C source files in all subdirectories of nut/

(setq auto-mode-alist (cons '(".*/nut/.*\\.[ch]$". nut-c-mode)
                       auto-mode-alist))</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_finishing_touches"></a>Finishing touches</h4></div></div></div><p>We like code that uses const and static liberally.  If you don’t need to
expose a function or global variable to the outside world, static is
your friend.  If nobody should edit the contents of some buffer that’s
behind a pointer, const keeps them honest.</p><p>We always compile with -Wall, so things like const and static help you
find implementation flaws.  Functions that attempt to modify a constant
or access something outside their scope will throw a warning or even
fail to compile in some cases.  This is what we want.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_switch_case_fall_through"></a>Switch case fall-through</h4></div></div></div><p>While C standards allow to write <code class="literal">switch</code> statements to "fall through"
from handling one case into another, modern compilers frown upon that
practice and spew warnings which complicate detecting real bugs in the
code (and also looking back at some of the cases written decades ago,
it is not trivial to state whether the fall-through was intentional or
really is a bug).</p><p>Compilers which detect such problem usually offer ways to decorate the
code with comments or attributes to keep it quiet it in cases where the
jump is intentional; also C++17 introduces special keywords for that in
the standard. NUT aiming to be portable and independent of compilers as
much as possible, prefers the arguably clearer and standards-based way
of using <code class="literal">goto</code> into the next intended operation, even though it is a
couple of lines away, e.g.:</p><pre class="literallayout">int uppercase = 0;
switch (char_opt) {
        case 'U':
                uppercase = 1;
                goto fallthrough_case_u_option;
        case 'u':
        fallthrough_case_u_option:
                process_u_option(uppercase);
                break;
}</pre><p>In trivial cases, like falling through to <code class="literal">default</code> which just returns,
it may be clearer and more maintainable (adding other option cases in
the future) to just <code class="literal">return same_result</code> in the code block that would
fall through otherwise and avoid <code class="literal">goto</code> statements altogether.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_spaghetti"></a>Spaghetti</h4></div></div></div><p>If you use a <code class="literal">goto</code> that jumps over long distances (see "Switch case
fall-through" section above), expect us to drop it when our head stops
spinning. It gives us flashbacks to the very old code we wrote.
We’ve tried to clean up our act, and you should make the effort
as well.</p><p>We’re not making a blanket statement about gotos, since everything
probably has at least one good use.  There are a few cases where a goto
is more efficient than any other approach, but you probably won’t
encounter them very often in this software.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_legacy_code"></a>Legacy code</h4></div></div></div><p>There are parts of the source tree that do not yet conform to these
specs.  Part of this is due to the fact that the coding style has been
evolving slightly over the course of the project.  Some of the code you
see in these directories is 5 years old, and things have gotten cleaner
since then.  Don’t worry — it’ll get cleaned up the next time something
in the vicinity gets a visit.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_memory_leak_checking"></a>Memory leak checking</h4></div></div></div><p>We can’t say enough good things about valgrind.  If you do anything with
dynamic memory in your code, you need to use this.  Just compile with
<code class="literal">gcc -g</code> and start the program inside <code class="literal">valgrind</code>.  Run it through the
suspected area and then exit cleanly.  valgrind will tell you if you’ve
done anything dodgy like freeing regions twice, reading uninitialized
memory, or if you’ve leaked memory anywhere.</p><p>For more information, refer to the <a class="ulink" href="http://valgrind.kde.org" target="_top">Valgrind</a>
project.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_conclusion"></a>Conclusion</h4></div></div></div><p>The summary: please be kind to our eyes.  There’s a lot of stuff in here,
and many people have put a lot of time and energy to improve it.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_submitting_patches"></a>3.7. Submitting patches</h3></div></div></div><p>Small patches that arrive in unified format (diff -u) as plain text
attachments with no HTML and a brief summary at the top are the easiest
to handle.</p><p>If a patch is sent to the nut-upsdev mailing list, it stands a better
chance of being seen immediately. However, it is likely to be dropped
if any issues cannot be resolved quickly. If your code might not work
for others, or if it is a large change, your best bet is to submit a
pull request or create an
<a class="ulink" href="https://github.com/networkupstools/nut/issues" target="_top">issue on GitHub</a>.</p><p>The issue tracker allows us to track the patches over a longer period
of time, and it is less likely that a patch will fall through the cracks.
Posting a reminder to the developers (via the nut-upsdev list) about a
patch on GitHub is fair game.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_patch_cohesion"></a>3.8. Patch cohesion</h3></div></div></div><p>Patches should have some kind of unifying element.  One patch set is one
message, and it should all touch similar things.  If you have to edit 6
files to add support for neutrino detection in UPS hardware, that’s
fine.</p><p>However, sending one huge patch that does massive separate changes all over
the tree is not recommended.  That kind of patch has to be split up and
evaluated separately, assuming the core developers care enough to do that
instead of just dropping it.</p><p>If you have to make big changes in lots of places, send multiple
patches — one per item.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_the_finishing_touches_manual_pages_and_device_entry_in_hcl"></a>3.9. The finishing touches: manual pages and device entry in HCL</h3></div></div></div><p>If you change something that involves an argument to a program or
configuration file parsing, the man page is probably now out of date.
If you don’t update it, we have to, and we have enough to do as it is.</p><p>If you write a new driver, send in the man page when you send us the
source code for your driver.  Otherwise, we will be forced to write a
skeletal man page that will probably miss many of the finer points of
the driver and hardware.</p><p>The same remark goes for device entries: if you add support for new models,
please remember to also complete the hardware compatibility list, present
in data/driver.list.in. This will be used to generate both textual, static
HTML and dynamic searchable HTML for the website.</p><p>Finally, don’t forget about fame and glory: if you added or substantially
updated a driver, your copyright belongs in the heading comment (along
with existing ones). For vendor backed (or sponsored) contributions we
welcome an entry in the docs/acknowledgements.txt file as well, to track
and know the industry players who help make NUT better and more useful.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_source_code_management"></a>3.10. Source code management</h3></div></div></div><p>We currently use a Git repository hosted at GitHub to track changes to
the NUT source code. This allows you to clone the repository (or fork,
in GitHub parlance), make changes, and post them online for peer review
prior to integration.</p><p>To obtain permission to commit directly to the common upstream NUT repository,
you must be prepared to spend a fair amount of time contributing to the
NUT codebase. Most developers will be well served by committing to their
own forked Git repository (preferably in a uniquely named branch for each
new contribution), and having the NUT team merge their changes using pull
requests.</p><p>Git offers a little more flexibility than the <code class="literal">svn update</code> command.
You may fetch other developers' changes into your repository, but hold
off on actually combining them with your branch until you have compared
the two branches (for instance, with <code class="literal">gitk --all</code>). Git also allows you
to accumulate more than one commit worth of changes before pushing to
another repository. This allows development to continue without a constant
network connection.</p><p>For a quick change to a file in the Git working copy, you can use
<code class="literal">git diff</code> to generate a patch to send to the nut-upsdev mailing list.
If you have more extensive changes, you can use <code class="literal">git format-patch</code> on
a complete commit or branch, and send the resulting series of patches
to the list.</p><p>If you use GitHub’s web-based editor to make changes, it tends to create
lots of small commits, one per change per file. Unless there is reason to
keep the intermediate history, we will probably collapse (or "squash" in
Git parlance) the entire branch into one commit with a <code class="literal">git rebase -i</code>
before merging.</p><p>The <a class="ulink" href="https://git.wiki.kernel.org/index.php/GitSvnCrashCourse" target="_top">GitSvnCrashCourse</a>
wiki page has some useful information for long-time users of Subversion.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_git_access"></a>Git access</h4></div></div></div><p>Anonymous Git checkouts are possible:</p><pre class="literallayout">git clone git://github.com/networkupstools/nut.git</pre><p>or</p><pre class="literallayout">git clone https://github.com/networkupstools/nut.git</pre><p>if it is necessary to get around a pesky firewall that blocks the native
Git protocol.</p><p>For a quicker checkout (when you don’t need the entire repository history),
you can limit the depth of the clone:</p><pre class="literallayout">git clone --depth 1 git://github.com/networkupstools/nut.git</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_mercurial_hg_access"></a>Mercurial (hg) access</h4></div></div></div><p>There are those who prefer the simplicity and self-consistency of the
Mercurial SCM client over the hodgepodge of unique commands which make
up Git. Rather than debate the merits of each system, we will gently
guide you towards the <a class="ulink" href="http://hg-git.github.com/" target="_top">hg-git project</a>
which would theoretically be a transparent bridge between the central
Git repository, and your local Mercurial working copy.</p><p>Other tools for hg/git interoperability are sure to exist. We would
welcome any feedback about this process on the nut-upsdev mailing list.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_subversion_svn_access"></a>Subversion (SVN) access</h4></div></div></div><p>If you prefer to check out the NUT source code using an SVN client, GitHub
has a <a class="ulink" href="https://github.com/blog/966-improved-subversion-client-support" target="_top">SVN
interface to Git repositories</a> hosted on their servers. You can fork a copy
of the NUT repository and commit to your fork with SVN.</p><p>Be aware that the examples in the GitHub blog post might result in a
checkout that includes all of the current branches, as well as the trunk.
You are most likely interested in a command line similar to the following:</p><pre class="literallayout">svn co https://github.com/networkupstools/nut/trunk nut-trunk-svn</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_ignoring_generated_files"></a>3.11. Ignoring generated files</h3></div></div></div><p>The NUT repository generally only holds files which are not generated from
other files. This prevents spurious differences from being recorded in the
repository history.</p><p>If you add a driver, it is recommended that you add the driver executable
name to the <code class="literal">.gitignore</code> file in that directory. Similarly, files generated
from <code class="literal">*.in</code> and <code class="literal">*.am</code> source templates should be ignored as well.
We try to include a number of generated files in the tarball releases with
<code class="literal">make dist</code> hooks in order to minimize the number of dependencies for end
users, but the assumption is that a developer can install the packages
needed to regenerate those files.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_commit_message_formatting"></a>3.12. Commit message formatting</h3></div></div></div><p>From the <code class="literal">git commit</code> man page:</p><div class="blockquote"><blockquote class="blockquote"><p>Though not required, it’s a good idea to begin the commit message with a
single short (less than 50 character) line summarizing the change, followed
by a blank line and then a more thorough description. The text up to the
first blank line in a commit message is treated as the commit title, and
that title is used throughout git.</p></blockquote></div><p>If your commit is just a change to one component, such as the HCL, upsd or a
specific driver, prefix your commit message in a way that matches similar
commits. This helps when searching the repository or tracking down a
regression.</p><p>Referring to previous commits can be tricky. If you are referring to the
immediate parent of a given commit, it suffices to say "the previous commit".
(Are you correcting a typo in the previous commit? If you haven’t pushed yet,
consider using the <code class="literal">git commit --amend</code> command instead of creating a new
commit.) For other commits, even though tools like gitk and GitHub’s
repository viewers recognize Git hashes and create links automatically, it is
best to add some context such as the commit title or a date.</p><p>You may notice that some older commits have <code class="literal">[[SVN:####]]</code> tags and Fossil-ID
footers. These were lifted from the old SVN commit messages using reposurgeon,
and should <span class="strong"><strong>not</strong></span> be used as a guide for future commits.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_repository_etiquette_and_quality_assurance"></a>3.13. Repository etiquette and quality assurance</h3></div></div></div><p>For developers who have commit access to the common upstream NUT repository:
Please keep the Git "master" branch in working condition at all times.
The "master" branch may be used to generate daily tarballs, it provides the
baseline for new contributions, and occasionally is tagged for a new release.
It should not contain broken code. If you need to commit incremental changes
that leave the system in a broken state, please do so in a separate branch
and merge the changes back into "master" once they are complete.</p><p>To help keep the codebase ever-green, we run a number of CI tests and builds
in various conditions, including older compilers, different C/C++ standard
revisions, and an assortment of operating systems; a section below elaborates
on this in more detail.</p><p>You are encouraged to use <code class="literal">git rebase -i</code> on your private Git branches to
separate your changes into <a class="link" href="ar01s03.html#_patch_cohesion" title="3.8. Patch cohesion">logical changes</a>.</p><p>From there, you can generate patches for the issue tracker, or the nut-upsdev
mailing list.</p><p>Note that once you rebase a branch, anyone else who has a copy of this branch
will need to rebase on top of your rebased branch. Obviously, this hinders
collaboration. In this case, we recommend that you rebase only in your private
repository, and push when things are ready for discussion. Merging instead of
rebasing will help with collaboration, but please do not turn the repository
history into a pile of spaghetti by merging unnecessarily. (Test merges can be
done on integration branches, which can be discarded if the merge is trivial.)
Be sure that your commit messages are descriptive when merging.</p><p>If you haven’t created a commit out of your local changes yet, and you want to
fetch the latest code, you can also use <code class="literal">git stash</code> before pulling, then <code class="literal">git
stash pop</code> to apply your saved changes.</p><p>Here is an example workflow:</p><pre class="screen">        git clone -o central git://github.com/networkupstools/nut.git

        cd nut
        git remote add -f username git://github.com/username/nut.git

        git checkout master
        git branch my-new-feature
        git checkout my-new-feature

        # Hack away

        git add changed-file.c
        git commit

        # Fix a typo in a file or commit message:

        git commit -a --amend

        # Someone committed something to the central repository. Fetch it.

        git fetch central
        git rebase central/master

        # Publish your branch to your GitHub repository:

        git push username my-new-feature</pre><p>If you are new to Git, but are familiar with SVN, the
<a class="ulink" href="http://git-scm.com/course/svn.html" target="_top">following link</a> may be of use.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="building"></a>3.14. Building the Code</h3></div></div></div><p>For a developer, the NUT build process starts with <code class="literal">./autogen.sh</code>. This script
generates the <code class="literal">./configure</code> script that end users typically invoke to build
NUT. If you are making a number of changes to the NUT source tree, configuring
with the <code class="literal">--enable-maintainer-mode</code> flag will ensure that after you change
<code class="literal">Makefile.am</code>, the <code class="literal">Makefile.in</code> and <code class="literal">Makefile</code> get regenerated. At a
minimum, you will need:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
autoconf
</li><li class="listitem">
automake
</li><li class="listitem">
libtool
</li><li class="listitem">
Python
</li><li class="listitem">
Perl
</li></ul></div><p>After running <code class="literal">./autogen.sh</code>, you can pass your local configuration options to
<code class="literal">./configure</code> and run <code class="literal">make</code> from the top-level directory. To avoid the need
for root privileges when testing new NUT code, you may wish to use
<code class="literal">--prefix=$HOME/local/nut --with-statepath=/tmp</code>. You can also keep
compilation times down by only building the driver you are currently working
on: <code class="literal">--with-drivers=driver1,dummy-ups</code>.</p><p>Before pushing your commits upstream, please run <code class="literal">make distcheck-light</code>.
This checks that the Makefiles are not broken, that all the relevant files
are distributed, and that there are no compilation or installation errors.
Note that unless you specifically pass <code class="literal">--with-doc=skip</code> to <code class="literal">configure</code>,
this requires all of the dependencies necessary to build the documentation
to be locally installed on your system, including asciidoc, a2x, xsltproc,
dblatex and any additional XSL stylesheets.</p><p>Running <code class="literal">make distcheck-light</code> is especially important if you have added or
removed files, or updated configure.ac or some Makefile.am.  Remember: simply
adding a file to Git does not mean it will be distributed. To distribute a
file, you must update the corresponding Makefile.am.</p><p>There is also <code class="literal">make distcheck</code>, which runs an even stricter set of
tests than <code class="literal">make distcheck-light</code>, but will not work unless you have all the
optional libraries and features installed.</p><p>Finally note, that since 2017 the GitHub upstream project is monitored by
Travis CI (in addition to multi-platform buildbots which occasionally do not
work). This means that if your posted improvements are based on current NUT
"master" branch, the resulting pull request should get tested for a number of
scenarios automatically. If your code adds a substantial feature, consider
extending the <code class="literal">.travis.yml</code> and/or <code class="literal">ci_build.sh</code> scripts in the workspace
root to add another <code class="literal">BUILD_TYPE</code> to the matrix of tests run in parallel.</p><p>Even if you do not use your distribution’s packages of NUT, installing the
distribution’s list of build dependencies for NUT can reduce the amount of
trial-and-error when installing dependencies. For instance, in Debian, you can
run <code class="literal">apt-get build-dep nut</code> to install all of the auto* tools as well as any
development libraries and headers.</p></div></div><div xmlns="" class="navfooter nut_footer"><hr />
		Last updated 2022-04-05 23:22:26 -- Network UPS Tools 2.8.0-rc1</div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>